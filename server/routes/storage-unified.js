"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// GENERATED by AI agent on 2025-09-26
const express_1 = __importDefault(require("express"));
const storage_blob_1 = require("@azure/storage-blob");
const azure_storage_js_1 = require("../azure-storage.js");
const router = express_1.default.Router();
const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;
const containerName = process.env.AZURE_STORAGE_CONTAINER_NAME || 'knowledge';
/** Initialize Blob Service Client */
const getBlobServiceClient = () => {
    if (!connectionString) {
        throw new Error('AZURE_STORAGE_CONNECTION_STRING is not configured');
    }
    return storage_blob_1.BlobServiceClient.fromConnectionString(connectionString);
};
/** Path normalization helper */
const BASE = (process.env.STORAGE_BASE_PREFIX ?? 'knowledge-base')
    .replace(/^[\\/]+|[\\/]+$/g, '');
const norm = (p) => [BASE, String(p || '')]
    .filter(Boolean)
    .join('/')
    .replace(/\\+/g, '/')
    .replace(/\/+/g, '/'); // ÈÄ£Á∂ö„Çπ„É©„ÉÉ„Ç∑„É•„ÇÇÁµ±‰∏Ä
/** Extract title from JSON content */
const extractTitle = async (containerClient, blobName) => {
    try {
        const blockBlobClient = containerClient.getBlockBlobClient(blobName);
        const downloadResponse = await blockBlobClient.download();
        if (downloadResponse.readableStreamBody) {
            const chunks = [];
            for await (const chunk of downloadResponse.readableStreamBody) {
                chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
            }
            const content = Buffer.concat(chunks).toString('utf-8');
            // BOMÈô§Âéª
            const cleanContent = content.replace(/^\uFEFF/, '');
            // ÂÖàÈ†≠4KB„ÅÆ„Åø„Çí„Éë„Éº„Çπ
            const jsonContent = cleanContent.substring(0, 4096);
            const jsonData = JSON.parse(jsonContent);
            return jsonData.title || jsonData.name || blobName.split('/').pop() || blobName;
        }
    }
    catch (error) {
        console.warn(`Failed to extract title from ${blobName}:`, error.message);
    }
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Éï„Ç°„Ç§„É´Âêç„Çí‰ΩøÁî®
    return blobName.split('/').pop() || blobName;
};
/**
 * GET /api/storage/list?prefix=exports/
 * List JSON files in the specified prefix with metadata
 */
router.get('/list', async (req, res) => {
    try {
        const prefix = String(req.query.prefix || '');
        if (!prefix) {
            return res.status(400).json({
                error: 'prefix parameter is required'
            });
        }
        // „Éë„ÇπÊ≠£Ë¶èÂåñ„Å®Êú´Â∞æ„Çπ„É©„ÉÉ„Ç∑„É•‰øùË®º
        const normalizedPrefix = norm(prefix).replace(/\/$/, '') + '/';
        console.log('üîç Storage list request:', {
            originalPrefix: prefix,
            normalizedPrefix,
            containerName
        });
        if (!connectionString) {
            console.warn('‚ö†Ô∏è Azure Storage not configured, returning empty list');
            return res.json([]);
        }
        const blobServiceClient = getBlobServiceClient();
        const containerClient = blobServiceClient.getContainerClient(containerName);
        const items = [];
        for await (const blob of containerClient.listBlobsFlat({ prefix: normalizedPrefix })) {
            // Only include .json files
            if (!blob.name.endsWith('.json'))
                continue;
            // Extract title from JSON content
            const title = await extractTitle(containerClient, blob.name);
            items.push({
                name: blob.name,
                updatedAt: blob.properties.lastModified?.toISOString() || new Date().toISOString(),
                sizeBytes: blob.properties.contentLength || 0,
                title,
                etag: blob.properties.etag || ''
            });
        }
        console.log(`‚úÖ Storage list completed: ${items.length} items`);
        res.json(items);
    }
    catch (error) {
        console.error('‚ùå Storage list error:', error);
        res.status(500).json({
            error: 'storage_list_error',
            message: error instanceof Error ? error.message : 'Unknown error'
        });
    }
});
/**
 * GET /api/storage/json/:name
 * Get JSON content from blob storage
 */
router.get('/json/:name', async (req, res) => {
    try {
        const { name } = req.params;
        const normalizedName = norm(name);
        console.log('üìÑ JSON get request:', { originalName: name, normalizedName });
        if (!azure_storage_js_1.azureStorage) {
            return res.status(500).json({
                error: 'Azure Storage not configured'
            });
        }
        const content = await azure_storage_js_1.azureStorage.readFileAsString(normalizedName);
        const jsonData = JSON.parse(content);
        // Set ETag header for caching
        const blobServiceClient = getBlobServiceClient();
        const containerClient = blobServiceClient.getContainerClient(containerName);
        const blockBlobClient = containerClient.getBlockBlobClient(normalizedName);
        const properties = await blockBlobClient.getProperties();
        res.set('ETag', properties.etag);
        res.set('Content-Type', 'application/json; charset=utf-8');
        res.json(jsonData);
    }
    catch (error) {
        console.error('‚ùå JSON get error:', error);
        if (error.statusCode === 404) {
            res.status(404).json({
                error: 'file_not_found',
                message: `File ${req.params.name} not found`
            });
        }
        else {
            res.status(500).json({
                error: 'json_get_error',
                message: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }
});
/**
 * PUT /api/storage/json/:name
 * Save JSON content to blob storage with ETag support
 */
router.put('/json/:name', async (req, res) => {
    try {
        const { name } = req.params;
        const normalizedName = norm(name);
        const ifMatch = req.headers['if-match'];
        console.log('üíæ JSON put request:', {
            originalName: name,
            normalizedName,
            hasIfMatch: !!ifMatch
        });
        if (!azure_storage_js_1.azureStorage) {
            return res.status(500).json({
                error: 'Azure Storage not configured'
            });
        }
        const blobServiceClient = getBlobServiceClient();
        const containerClient = blobServiceClient.getContainerClient(containerName);
        const blockBlobClient = containerClient.getBlockBlobClient(normalizedName);
        // Check ETag if provided
        if (ifMatch) {
            try {
                const properties = await blockBlobClient.getProperties();
                if (properties.etag !== ifMatch) {
                    return res.status(412).json({
                        error: 'precondition_failed',
                        message: 'ETag mismatch - file was modified by another process'
                    });
                }
            }
            catch (error) {
                if (error.statusCode !== 404) {
                    throw error;
                }
                // File doesn't exist, which is fine for new files
            }
        }
        const content = JSON.stringify(req.body, null, 2);
        await azure_storage_js_1.azureStorage.writeStringToFile(normalizedName, content);
        // Get new ETag
        const newProperties = await blockBlobClient.getProperties();
        res.json({
            success: true,
            etag: newProperties.etag,
            name: normalizedName,
            size: content.length
        });
    }
    catch (error) {
        console.error('‚ùå JSON put error:', error);
        res.status(500).json({
            error: 'json_put_error',
            message: error instanceof Error ? error.message : 'Unknown error'
        });
    }
});
/**
 * GET /api/storage/image-url?name=images/sample.png
 * Generate short-lived SAS URL for image access
 */
router.get('/image-url', async (req, res) => {
    try {
        const name = req.query.name;
        if (!name) {
            return res.status(400).json({
                error: 'name parameter is required'
            });
        }
        const normalizedName = norm(name);
        console.log('üñºÔ∏è Image SAS request:', {
            originalName: name,
            normalizedName
        });
        if (!connectionString) {
            return res.status(500).json({
                error: 'Azure Storage not configured'
            });
        }
        const blobServiceClient = getBlobServiceClient();
        const containerClient = blobServiceClient.getContainerClient(containerName);
        const blockBlobClient = containerClient.getBlockBlobClient(normalizedName);
        // Check if blob exists
        const exists = await blockBlobClient.exists();
        if (!exists) {
            return res.status(404).json({
                error: 'image_not_found',
                message: `Image ${name} not found`
            });
        }
        // Generate SAS token (15 minutes expiry)
        const sasOptions = {
            containerName,
            blobName: normalizedName,
            permissions: storage_blob_1.BlobSASPermissions.parse('r'), // Read only
            startsOn: new Date(),
            expiresOn: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes
        };
        const sasToken = (0, storage_blob_1.generateBlobSASQueryParameters)(sasOptions, blobServiceClient.credential).toString();
        const sasUrl = `${blockBlobClient.url}?${sasToken}`;
        res.json({
            url: sasUrl
        });
    }
    catch (error) {
        console.error('‚ùå Image SAS error:', error);
        res.status(500).json({
            error: 'image_sas_error',
            message: error instanceof Error ? error.message : 'Unknown error'
        });
    }
});
exports.default = router;
